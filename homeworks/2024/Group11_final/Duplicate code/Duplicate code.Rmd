---
header-includes:
  - \usepackage{ctex}
title: "对《Overperception of moral outrage in online social networks inflates beliefs about intergroup hostility》的可重复性研究——代码部分"
author: "沈玫霖、乔骊珠、吴惜之、包珺、李慧"
date: "2024-06-07"
output: 
  pdf_document:
    latex_engine: xelatex
    template: "default"
---
\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA, fig.width = 6, fig.height = 4)
options(width = 100)
options(repos = c(CRAN = "https://cran.r-project.org"))
if (!requireNamespace("showtext", quietly = TRUE)) {
  install.packages("showtext")
}
library(showtext)
showtext_auto()
font_add("SimHei", "SimHei.ttf")
library(grid)
```

# 研究1
## 前期准备
```{r, message=FALSE, results='hide'}
#检查是否安装所需要的R包，如果没有就下载
packages <- c("tidyverse", "kableExtra", "psych", "Hmisc", "lmerTest")
 lapply(packages, function(pkg) {     
  if (!requireNamespace(pkg, quietly = TRUE)) { 
    install.packages(pkg, dependencies = TRUE)  
  }
})

#加载R包
library(tidyverse)
library(kableExtra)
library(psych)
library(Hmisc)
library(lmerTest)

#设置工作路径
setwd("C:/Users/sml/Desktop/R/大作业/复刻代码")

#读取文件
self_report <- read_csv("../osfstorage-archive/Data/study1_self_report.csv")
data <- read_csv("../osfstorage-archive/Data/study1_data_raw.csv")
```

```{r, message=FALSE}
#函数1：frequencies.table()的作用是计算变量的频数、百分比，并将结果以美观的表格呈现
frequencies.table <- function(variable, label) {
  freq <- table(variable)
  prop <- prop.table(table(variable))
  perc <- prop*100 
  combined <- cbind(freq, perc)
  kable((combined), format = "latex",col.names = c("Freq", "%"), digits = 2) %>%
    kable_styling(bootstrap_options = "striped",full_width = FALSE, position = "left")
}
 
#函数2：corr.matrix()的作用是计算变量之间的相关系数，评估显著性，呈现在表格里
corr.matrix <- function(x){ 
  x <- as.matrix(x) 
  R <- Hmisc::rcorr(x)$r 
  p <- Hmisc::rcorr(x)$P 
  mystars <- ifelse(p < .001, "***", 
                    ifelse(p < .01, "** ", ifelse(p < .05, "* ", " ")))
  R <- format(round(cbind(rep(-1.11, ncol(x)), R), 2))[,-1] 
  Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x))
  diag(Rnew) <- paste(diag(R), " ", sep="") 
  rownames(Rnew) <- colnames(x) 
  colnames(Rnew) <- paste(colnames(x), "", sep="") 
  Rnew <- as.matrix(Rnew)
  Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
  Rnew <- as.data.frame(Rnew) 
  Rnew <- cbind(Rnew[1:length(Rnew)-1])
  return(Rnew)
}
 
#函数3：numextract()的作用是从字符串中提取数字
numextract <- function(string){ 
  str_extract(string, "\\-*\\d+\\.*\\d*")
} 
```

## 数据处理
```{r, message=FALSE}
# 添加性别标签的变量gender_label到data中
data <- data %>% mutate(gender_label = 
                          ifelse(gender == 1, "Male",
                                 ifelse(gender == 2, "Female", "Other")))

# 添加党派标签party_label的变量到data中
data <- data %>% mutate(
  party_label = 
    ifelse(party == 1, "Democrat",
           ifelse(party == 2, "Republican",
                  ifelse(party == 3, "Indepedent",
                         ifelse(party == 4, "Other","None")))))

# 添加党派认同程度的变量p_identity到data中
#若sis_dem缺失，则使用sis_rep的数据
data <- data %>% mutate(p_identity = ifelse(is.na(sis_dem) == TRUE,
                                            sis_rep, sis_dem))

# 添加意识形态极端程度ideo_extr的变量到data中，使用的是绝对值
data <- data %>% mutate(ideo_extr = abs(ideo))
```

```{r}
#注意力检测的频数表
frequencies.table(data$comp_check)
```

```{r, message=FALSE}
#剔除未通过注意力检测的观察者
data_trim <- data %>% filter(comp_check == 1)

#剔除党派类别除"Democrat"和"Republican"之外的观察者
data_trim <- data_trim %>% filter(party_label == "Democrat" | 
                                    party_label == "Republican")
```

## 描述性统计
```{r}
#观察者性别频数分布表
frequencies.table(data_trim$gender_label)
```

```{r,fig.show='hide',message=FALSE}
#观察者年龄的直方图
hist_data <- hist(data_trim$age,
                  plot = FALSE)

plot(hist_data,
     main = "观察者年龄分布的直方图",
     xlab = "年龄",
     ylab = "频数",
     col = "lightblue",
     border = "black")
```

```{r}
ggplot(data_trim, aes(x = age)) +
  geom_histogram(breaks = hist_data$breaks,  
                 fill = "lightblue", 
                 color = "black") +
  labs(title = "观察者年龄分布的直方图", 
       x = "年龄", 
       y = "频数") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    text = element_text(family = "SimHei")
  )

#观察者意识形态频数分布表
frequencies.table(data_trim$ideo)

#观察者党派频数分布表
frequencies.table(data_trim$party_label)
```

```{r,fig.show='hide',message=FALSE}
#观察者党派认同程度的直方图和平均值
hist_data <- hist(data_trim$p_identity,
                  plot = FALSE)

plot(hist_data,
     main = "观察者党派认同程度的直方图",
     xlab = "观察者党派认同程度",
     ylab = "频数",
     col = "lightblue",
     border = "black")
```

```{r}
ggplot(data_trim, aes(x = p_identity)) +
  geom_histogram(binwidth = 1, 
                 fill = "lightblue", 
                 color = "black",
                 boundary = 2) +  # 确保柱子连在一起
  labs(title = "观察者党派认同程度的直方图", 
       x = "观察者党派认同程度", 
       y = "频数") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    text = element_text(family = "SimHei")
  ) +
  coord_fixed(ratio = 1/5)  

round(mean(data_trim$p_identity, na.rm = TRUE),2)

#观察者党派认同程度的密度图
data_trim %>%
  ggplot(aes(x = p_identity)) +
  geom_density(fill = "lightblue", alpha = .8) +
  labs(title = "观察者党派认同程度的密度图", x = "观察者党派认同程度", 
       y = "密度") +
  geom_vline(xintercept = 5.5, linetype = "dashed", color = "red") +
  geom_vline(xintercept = 4, linetype = "dashed") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    text = element_text(family = "SimHei")
  )
```

## 过度感知的分析
### 愤怒部分
```{r,message=FALSE}
#选择data_trim表格中”or“结尾的列，代表与愤怒情绪(or: outrage)相关的评分
data_or_trans <- data_trim %>% select(ends_with("_or")) %>% 
  t() %>% # 转置数据框，使得每一行代表一个推文的评分
  as.data.frame() %>% # 将矩阵转换为数据框
  mutate(tweet_id = as.integer(numextract(rownames(.))), 
         tweet_id_char = rownames(.)) %>%
  #使用numextract函数从行名中提取数字,创建新的推文ID列
  arrange(tweet_id)# 根据推文ID进行排列

# 计算每个推文被感知的平均愤怒程度
data_or_trans$mean_or <- data_or_trans %>% 
  select(-c(tweet_id, tweet_id_char)) %>% rowMeans(., na.rm = TRUE)

# 引入自我报告评分进行比较，根据tweet_id进行合并
data_or_trans <- data_or_trans %>% left_join(self_report, 
                                             by = "tweet_id")

# 选择数据框data_or_trans中的列V1到V110，以及tweet_id和sr_outrage
data_mlm <- data_or_trans %>% select(V1:V110, tweet_id, sr_outrage) %>% 
  pivot_longer(cols = -c(tweet_id, sr_outrage),
               values_to = "judgment",
               names_to = "pid",
               values_drop_na = TRUE)

# 为数据框data_mlm添加一个新列name，并将其值设为"perceiver"（观察者）
data_mlm <- data_mlm %>% mutate(name = "perceiver")

# 从self_report数据框中选择tweet_id和sr_outrage列
#为每一行添加一个pid，其值为tweet_id的行号
self_report_trim <- self_report %>% select(tweet_id, sr_outrage) %>% 
  mutate(pid = as.character(row_number(tweet_id)))

# 选择tweet_id列，然后添加一个新列name设为"author"
#并与self_report_trim数据框进行左连接，再将judgment列的值设为sr_outrage
data_mlm2 <- data_mlm %>% select(tweet_id) %>% 
  mutate(name = "author") %>% left_join(self_report_trim, 
                                        by = "tweet_id") %>% 
  mutate(judgment = sr_outrage)

# 创建一个列的顺序顺序
col_order <- c("tweet_id", "sr_outrage", "pid",
               "judgment", "name")

# 根据列的顺序重新排列data_mlm2数据框
data_mlm2 <- data_mlm2[, col_order]

# 将data_mlm和data_mlm2合并，按tweet_id排序
#添加一个新列name_dum，其值为如果name为"author"则为0，否则为1
data_mlm3 <- rbind(data_mlm, data_mlm2) %>% arrange(tweet_id) %>% 
  mutate(name_dum = ifelse(name == "author", 0, 1))

# 设置options以控制科学计数法的显示，scipen=999表示不使用科学计数法
options(scipen = 999)
```

```{r}
# 多层次模型固定效应部分包括变量name，随机效应包括tweet_id和pid的随机截距
model_or <- lmer(
  judgment ~ name + (1 | tweet_id) + (1 | pid), 
  data = data_mlm3 
)
summary(model_or)
round(confint(model_or, level = 0.95),2)
```

```{r, message=FALSE, warning=FALSE}
#观察者和作者愤怒评分的小提琴图
p_or <- ggplot(data_mlm3, aes(x = name, y = judgment, fill = name)) +
  geom_violin(trim = FALSE, bw = 0.5) + 
  geom_point(stat = "summary", fun = "mean", color = "black", size = 3) +
  geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) +
  scale_fill_manual(values = c("author" = "lightgreen", 
                               "perceiver" = "lightcoral")) +
  scale_y_continuous(breaks = 1:7, limits = c(1, 7)) +  
  labs(x = "", y = "愤怒评分", title = "观察者和作者愤怒评分的小提琴图") + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 15),
    axis.text.x = element_text(size = 12),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  )
print(p_or)
```

### 快乐部分(同愤怒部分)
```{r,message=FALSE}
data_hap_trans <- data_trim %>% select(ends_with("_hap")) %>%
  t() %>% 
  as.data.frame() %>% 
  mutate(tweet_id = as.integer(numextract(rownames(.))), 
         tweet_id_char = rownames(.)) %>% 
  arrange(tweet_id)

data_hap_trans$mean_hap <- data_hap_trans %>% 
  select(-c(tweet_id, tweet_id_char)) %>% rowMeans(., na.rm = TRUE)

data_hap_trans <- data_hap_trans %>% left_join(self_report, 
                                               by = "tweet_id")

data_mlmh <- data_hap_trans %>% select(V1:V110, tweet_id, sr_happy) %>% 
  pivot_longer(cols = -c(tweet_id, sr_happy),
               values_to = "judgment",
               names_to = "pid",
               values_drop_na = TRUE)

data_mlmh <- data_mlmh %>% mutate(name = "perceiver")


self_report_trimh <- self_report %>% select(tweet_id, sr_happy) %>% 
  mutate(pid = as.character(row_number(tweet_id)))


data_mlm2h <- data_mlmh %>% select(tweet_id) %>% 
  mutate(name = "author") %>% left_join(self_report_trimh, 
                                        by = "tweet_id") %>% 
  mutate(judgment = sr_happy)


col_orderh <- c("tweet_id", "sr_happy", "pid",
                "judgment", "name")

data_mlm2h <- data_mlm2h[, col_orderh]


data_mlm3h <- rbind(data_mlmh, data_mlm2h) %>% arrange(tweet_id) %>% 
  mutate(name_dum = ifelse(name == "author", 0, 1))


options(scipen = 999)
```

```{r}
model_hap<- lmer(judgment ~ name + (1 | tweet_id) + (1 |pid), 
                 data = data_mlm3h)
summary(model_hap)
round(confint(model_hap, level = 0.95),2)
```

```{r, message=FALSE, warning=FALSE}
p_hap <- ggplot(data_mlm3h, aes(x = name, y = judgment, fill = name)) +
  geom_violin(trim = FALSE, bw = 0.5) + 
  geom_point(stat = "summary", fun = "mean", color = "black", size = 3) +
  geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) +
  scale_fill_manual(values = c("author" = "lightgreen", "perceiver" = "lightcoral")) +
  scale_y_continuous(breaks = 1:7, limits = c(1, 7)) +  
  labs(x = "", y = "快乐评分", title = "观察者和作者快乐评分的小提琴图") + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 15),
    axis.text.x = element_text(size = 12),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  )
print(p_hap)
```

# 研究2
## 数据预处理
```{r,message=FALSE}
# 读取文件储存在变量中
self_report_study2 <- read_csv("../osfstorage-archive/Data/study2_self_report.csv")
data_study2 <- read_csv("../osfstorage-archive/Data/study2_data_raw.csv")

# 数据预处理
# 性别标签（age）
data_study2 <- data_study2 %>% mutate(
  gender_label = ifelse(gender == 1, "Male",
                        ifelse(gender == 2, "Female", "Other")))
# 党派标签（party）
data_study2 <- data_study2 %>% 
  mutate(party_label = 
           ifelse(party == 1, "Democrat",
                  ifelse(party == 2, "Republican",
                         ifelse(party == 3, "Indepedent",
                                ifelse(party == 4, "Other", "None")))))

# 使用mutate()和ifelse()函数为数据框data添加一个新列p_identity
# 如果sis_dem列的值是NA，则取sis_rep列的值；否则取sis_dem列的值
data_study2 <- data_study2 %>% 
  mutate(p_identity = ifelse(is.na(sis_dem) == TRUE, sis_rep, sis_dem))

# 使用mutate()和abs()函数为数据框data添加一个新列ideo_extr
# 计算ideo列的绝对值
data_study2 <- data_study2 %>% mutate(ideo_extr = abs(ideo))

# 使用之前定义的frequencies.table函数来查看comp_check列的分布情况
frequencies.table(data_study2$comp_check)

# 使用filter()函数从data中移除comp_check列值为非1的行，即移除未通过理解检查的行
data_trim_study2 <- data_study2 %>% filter(comp_check == 1)

# 剔除Democrat.Republican外的党派
data_trim_study2 <- data_trim_study2 %>% 
  filter(party_label == "Democrat" | party_label == "Republican")
```

## 描述性统计
```{r,warning=FALSE,message=FALSE}
# 使用frequencies.table函数查看data_trim中gender_label列的分布情况
frequencies.table(data_trim_study2$gender_label)

# 使用ggplot()函数为data_trim中age列的值绘制直方图
ggplot(data_trim_study2, aes(x = age)) +
  geom_histogram(bins = 30, fill = "lightblue", alpha = 0.8, color = "black") + 
  labs(x = "年龄", y = "频次", title = "年龄分布直方图") + 
  theme_minimal() + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  scale_x_continuous(limits = c(0, max(data_trim_study2$age))) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

# 使用frequencies.table函数查看data_trim中ideo列的分布情况
frequencies.table(data_trim_study2$ideo)

# 使用frequencies.table函数查看data_trim中party_label列的分布情况
frequencies.table(data_trim_study2$party_label)

#p_identity列的值绘制直方图并计算均值
mean_p_identity_study2 <- mean(data_trim_study2$p_identity, na.rm = TRUE)

ggplot(data_trim_study2, aes(x = p_identity)) +
  geom_histogram(bins = 30, fill = "skyblue", alpha = 0.7, color = "black") + # 绘制直方图
  geom_vline(aes(
    xintercept = mean_p_identity_study2), 
    color = "red", linetype = "dashed", size = 1) + # 添加表示均值的虚线
  labs(x = "政治认同强度", y = "频次", 
       title = "政治认同强度分布直方图") + # 设置轴标签和图标题
  theme_minimal() + # 使用简洁主题
  theme(
    plot.title = element_text(hjust = 0.5), # 居中图标题
    axis.title.x = element_text(face = "bold"), # 粗体X轴标题
    axis.title.y = element_text(face = "bold"), # 粗体Y轴标题
    axis.text = element_text(color = "black"), # 轴文本颜色
    axis.line = element_line(color = "black"), # 轴线颜色
    panel.grid.major = element_line(
      color = "grey80", linetype = "dotted"), # 主网格线样式
    panel.grid.minor = element_blank(), # 移除次网格线
    panel.border = element_blank() # 移除面板边框
  ) +
  theme(panel.grid = element_blank()) # 移除面板网格线

# 使用ggplot2包绘制p_identity列的密度图，并添加一些额外的可视化元素
data_trim_study2 %>% ggplot(aes(x = p_identity)) +
  geom_density(fill = "lightblue", alpha = .8) +
  xlab("政治认同强度") +
  ylab("密度") +
  geom_vline(xintercept = 5.5, 
             linetype = "dashed", color = "red") +  # 添加虚线表示特定值
  geom_vline(xintercept = 4, linetype = "dashed") +
  theme_bw() +  # 设置主题为黑白，并移除边框和轴线
  theme(panel.border = element_blank(), axis.line = element_line()) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) + # 移除主要和次要的网格线
  theme(text=element_text(size = 15, face = 'bold'))  # 设置文本大小和粗体
```

## 主要的过度感知分析
```{r}
# 选择数据框data_trim中以"_or"结尾的列，这些列代表推特级别的评分
#然后转置数据，转换为数据框，并按推文ID排序
data_or_trans_study2 <- data_trim_study2 %>% select(ends_with("_or")) %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate(tweet_id = as.integer(numextract(rownames(.))), tweet_id_char = rownames(.)) %>% 
  arrange(tweet_id)

# 对于幸福感("_hap")的评分，执行与愤怒("_or")相同的操作
data_hap_trans_study2 <- data_trim_study2 %>% select(ends_with("_hap")) %>%
  t() %>% 
  as.data.frame() %>% 
  mutate(tweet_id = as.integer(numextract(rownames(.))), tweet_id_char = rownames(.)) %>% 
  arrange(tweet_id)

# 计算每个推文被感知的愤怒的平均值
data_or_trans_study2$mean_or <- data_or_trans_study2 %>% 
  select(-c(tweet_id, tweet_id_char)) %>% rowMeans(., na.rm = TRUE)

# 计算每个推文被感知的幸福感的平均值
data_hap_trans_study2$mean_hap <- data_hap_trans_study2 %>% 
  select(-c(tweet_id, tweet_id_char)) %>% rowMeans(., na.rm = TRUE)

# 将自我报告评分(self_report)通过推文ID与之前的数据合并，以便进行比较
data_or_trans_study2 <- data_or_trans_study2 %>% left_join(self_report_study2, by = "tweet_id")
data_hap_trans_study2 <- data_hap_trans_study2 %>% left_join(self_report_study2, by = "tweet_id")

#针对愤怒情绪进行多层次模型分析（MLM）
data_mlm_study2 <- data_or_trans_study2 %>% select(V1:V165, tweet_id, sr_outrage) %>% 
  pivot_longer(cols = -c(tweet_id, sr_outrage),
               values_to = "judgment",
               names_to = "pid",
               values_drop_na = TRUE)
# 添加一个表示评判者是观察者还是作者的变量
data_mlm_study2 <- data_mlm_study2 %>% mutate(name = "perceiver")
# 准备自我报告数据，以便与MLM数据合并
self_report_trim_study2 <- self_report_study2 %>% select(tweet_id, sr_outrage) %>% 
  mutate(pid = as.character(row_number(tweet_id)))
# 将自我报告数据添加到MLM数据中，并将评判值设置为自我报告的愤怒评分
data_mlm2_study2 <- data_mlm_study2 %>% select(tweet_id) %>% 
  mutate(name = "author") %>% left_join(self_report_trim_study2, by = "tweet_id") %>% 
  mutate(judgment = sr_outrage)
# 指定列的顺序
col_order_study2 <- c("tweet_id", "sr_outrage", "pid",
               "judgment", "name")
# 按指定的列顺序对数据_mlm2进行重排
data_mlm2_study2 <- data_mlm2_study2[, col_order]
# 合并观察者和作者的数据，并添加一个虚拟变量来区分两者
data_mlm3_study2 <- rbind(data_mlm_study2, data_mlm2_study2) %>% arrange(tweet_id) %>% 
  mutate(name_dum = ifelse(name == "author", 0, 1))
# 设置R的选项，以控制科学记数法的显示
options(scipen = 999)

# 拟合愤怒情绪的多层次模型 
model_or_study2 <- lmer(judgment ~ name + (1 | tweet_id) + (1 |pid), data = data_mlm3_study2) 
# 获取模型摘要 
summary(model_or_study2) 
# 获取置信区间 
confint(model_or_study2, level = 0.95) 

# 为幸福感情绪重复上述步骤，准备数据进行多层次模型分析
data_mlmh_study2 <- data_hap_trans_study2 %>% select(V1:V165, tweet_id, sr_happy) %>% 
  pivot_longer(cols = -c(tweet_id, sr_happy),
               values_to = "judgment",
               names_to = "pid",
               values_drop_na = TRUE)
# 添加一个表示评判者是观察者还是作者的变量
data_mlmh_study2 <- data_mlmh_study2 %>% mutate(name = "perceiver")

# 准备自我报告数据，以便与MLM数据合并
self_report_trimh_study2 <- self_report_study2 %>% select(tweet_id, sr_happy) %>% 
  mutate(pid = as.character(row_number(tweet_id)))

# 将自我报告数据添加到MLM数据中，并将评判值设置为自我报告的幸福感评分
data_mlm2h_study2 <- data_mlmh_study2 %>% select(tweet_id) %>% 
  mutate(name = "author") %>% left_join(self_report_trimh_study2, by = "tweet_id") %>% 
  mutate(judgment = sr_happy)
# 指定列的顺序
col_orderh_study2 <- c("tweet_id", "sr_happy", "pid",
                "judgment", "name")
# 按指定的列顺序对数据_mlm2h进行重排
data_mlm2h_study2 <- data_mlm2h_study2[, col_orderh]
# 合并观察者和作者的数据，并添加一个虚拟变量来区分两者
data_mlm3h_study2 <- rbind(data_mlmh_study2, data_mlm2h_study2) %>% arrange(tweet_id) %>% 
  mutate(name_dum = ifelse(name == "author", 0, 1))
# 设置R的选项，以控制科学记数法的显示
options(scipen = 999)

# 拟合幸福感情绪的多层次模型 
model_hap_study2 <- lmer(judgment ~ name + (1 | tweet_id) + (1 |pid), data = data_mlm3h_study2) 
# 获取模型摘要 
summary(model_hap_study2) 
# 获取置信区间 
confint(model_hap_study2, level = 0.95)
```

## 小提琴图
```{r,warning=FALSE}
# 创建一个ggplot对象，名为p_hap，使用数据集data_mlm3h
p_hap_study2 <- ggplot(data_mlm3h_study2, aes(x = name, y = judgment, fill = name)) + 

# 添加小提琴图层，展示数据分布
# trim = FALSE 表示不修剪小提琴图的边缘
# bw = 0.5 设置小提琴图的带宽
geom_violin(trim = FALSE, bw = 0.5) + 

# 添加点图层，展示每个组的平均值
# stat = "summary" 表示使用汇总统计
# fun = "mean" 指定使用平均值作为点的位置
# 点的颜色、大小设置
geom_point(stat = "summary", fun = "mean", color = "black", size = 3) + 

# 添加误差条图层，展示每个组平均值的标准误差
# fun.data 指定自定义函数，计算平均值的标准误差
# width 设置误差条的宽度
geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) + 

# 手动设置填充颜色，为不同的组分配不同的颜色
scale_fill_manual(values = c("author" = "lightgreen", "perceiver" = "lightcoral")) + 

# 设置y轴的刻度和范围
# breaks 定义y轴的刻度
# limits 定义y轴的范围
scale_y_continuous(breaks = 1:7, limits = c(1, 7)) + 

# 设置图表的标签和标题
# x轴标签为空
# y轴标签为"幸福指数"
# 图表标题为"观察者和作者的幸福指数"
labs(x = "", y = "幸福指数", title = "观察者和作者的幸福指数") + 

# 设置图表的主题，包括图例位置、轴标题大小、轴文本大小、标题样式等
theme( 
  legend.position = "none",  # 不显示图例
  axis.title.y = element_text(size = 15),  # y轴标题文字大小
  axis.text.x = element_text(size = 12),  # x轴文本大小
  plot.title = element_text(size = 16, face = "bold", hjust = 0.5)  # 标题样式
) 

# 打印或显示图表
print(p_hap_study2)


# 使用ggplot作图，复现文献Fig2中的b图
# 创建一个ggplot对象，名为p__or_study2，使用数据集data_mlm3h_study2
p_or_study2 <- ggplot(data_mlm3_study2, aes(x = name, y = judgment, fill = name)) + 
geom_violin(trim = FALSE, bw = 0.5) + 
geom_point(stat = "summary", fun = "mean", color = "black", size = 3) +
geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) + 
scale_fill_manual(values = c("author" = "lightgreen", "perceiver" = "lightcoral")) + 
scale_y_continuous(breaks = 1:7, limits = c(1, 7)) + 
labs(x = "", y = "愤怒指数", title = "观察者和作者的愤怒指数") + 
theme( 
  legend.position = "none",
  axis.title.y = element_text(size = 15), 
  axis.text.x = element_text(size = 12),
  plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
) 

# 打印或显示图表
print(p_or_study2)
```

# 研究1和研究2数据合并部分
## 过度感受愤怒和政治社交媒体使用的相关和回归
```{r, message=FALSE, warning=FALSE}
#读取文件储存
op1 <- read_csv("../osfstorage-archive/Data/study1_overperception.csv")
op2 <- read_csv("../osfstorage-archive/Data/study2_overperception.csv")

# 将两个数据框按行合并，存储在op_final中
op_final <- rbind(op1, op2)

# 对变量'sm_use_politics_slider'和'overperception'进行皮尔逊相关性检验
cor.test(op_final$sm_use_politics_slider, op_final$overperception, method = "pearson")


# 构建线性回归模型，解释变量为'overperception'
# 自变量为标准化后的'sm_use_politics_slider'、'ideo_extr'和'p_identity'
# 使用op_final数据框中的数据
summary(lm(overperception ~ scale(sm_use_politics_slider) +
             scale(ideo_extr) + scale(p_identity), data = op_final))

#过度感知愤怒和政治社交媒体使用的关系图
p_cor1 <- ggplot(op_final, aes(x = sm_use_politics_slider, 
                               y = overperception)) +
  geom_point(color = "red", alpha = 0.6) + 
  geom_smooth(method = "lm", color = "red", se = TRUE) + 
  theme_minimal() +
  labs(x = "", y = "过度感知愤怒平均分") + 
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    axis.title.y = element_text(size = 12),
    axis.text.y = element_text(size = 10),
    axis.text.x = element_text(size = 10)
  )
print(p_cor1)
```

# 研究3
## 读取数据与数据清洗
```{r,message=FALSE,warning=FALSE}
#读取数据
self_report_study3 <- 
  read_csv("../osfstorage-archive/Data/study2_self_report.csv")
data_study3 <- read_csv("../osfstorage-archive/Data/study3_data_raw.csv")

#数据清洗
# 性别
data_study3 <- data_study3 %>% mutate(gender_label = 
                          ifelse(gender == 1, "Male", 
                                 ifelse(gender == 2, "Female", "Other")))

# 党派
data_study3 <- data_study3 %>% mutate(
  party_label = 
    ifelse(party == 1, "Democrat", 
           ifelse(party == 2, "Republican",
                  ifelse(party == 3, "Indepedent",
                         ifelse(party == 4, "Other", "None")))))

# 政治身份强度
data_study3 <- data_study3 %>% mutate(
  p_identity = ifelse(is.na(sis_dem) == TRUE, sis_rep, sis_dem))

# 意识形态
data_study3 <- data_study3 %>% mutate(ideo_extr = abs(ideo))

# 数据剔除
frequencies.table(data_study3$comp_check)

data_trim_study3 <- data_study3 %>% filter(comp_check == 1)

data_trim_study3 <- data_trim_study3 %>% filter(
  party_label == "Democrat" | party_label == "Republican")
```

## 描述性统计（作图）
```{r,message=FALSE,warning=FALSE}
# 观察者性别频数分布表
frequencies.table(data_trim_study3$gender_label)

# 观察者年龄的直方图
hist_data_study3 <- hist(data_trim_study3$age,
                  plot = FALSE)
plot(hist_data_study3,
     main = " 观察者年龄分布的直方图",
     xlab = " 年龄",
     ylab = " 频数",
     col = "lightblue",
     border = "black")
ggplot(data_trim_study3, aes(x = age)) +
  geom_histogram(breaks = hist_data_study3$breaks,
                 fill = "lightblue",
                 color = "black") +
  labs(title = " 观察者年龄分布的直方图",
       x = " 年龄",
       y = " 频数") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    text = element_text(family = "SimHei")
  )

# 意识形态
frequencies.table(data_trim_study3$ideo)

# 党派
frequencies.table(data_trim_study3$party_label)

# 党派认同程度
p_identity_summary_study3 <-
  summary(data_trim_study3$p_identity)
print(p_identity_summary_study3)

# 观察者党派认同程度的直方图和平均值
hist_data_study3 <- hist(data_trim_study3$p_identity,
                  plot = FALSE)
plot(hist_data_study3,
     main = " 观察者党派认同程度的直方图",
     xlab = " 观察者党派认同程度",
     ylab = " 频数",
     col = "lightblue",
     border = "black")

ggplot(data_trim_study3, aes(x = p_identity)) +
  geom_histogram(binwidth = 1,
                 fill = "lightblue",
                 color = "black",
                 boundary = 2) + # 确保柱子连在一起
  labs(title = " 观察者党派认同程度的直方图",
       x = " 观察者党派认同程度",
       y = " 频数") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    text = element_text(family = "SimHei")
  ) +
  coord_fixed(ratio = 1/5)
round(mean(data_trim_study3$p_identity, na.rm = TRUE),2)

# 党派认同程度密度图
data_trim_study3 %>%
  ggplot(aes(x = p_identity)) +
  geom_density(fill = "lightblue", alpha = .8) +
  labs(title = "观察者党派认同程度的密度图", x = "观察者党派认同程度", y = "密度") +
  geom_vline(xintercept = 5.5, linetype = "dashed", color = "red") +
  geom_vline(xintercept = 4, linetype = "dashed") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), text = element_text(family = "SimHei"))
```

##选择、转置、计算平均和合并过度感知情绪相关的数据
```{r,message=FALSE,warning=FALSE}
# 选择与愤怒情绪相关的推文级别评分
# 然后转置、转换为数据框，并增加新列
data_or_trans_study3 <- data_trim_study3 %>%
  select(ends_with("_or")) %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate(tweet_id = as.integer(numextract(rownames(.))),
         tweet_id_char = rownames(.)) %>% 
  arrange(tweet_id)

# 选择与快乐情绪相关的推文级别评分，执行与愤怒情绪相同的操作
data_hap_trans_study3 <- data_trim_study3 %>%
  select(ends_with("_hap")) %>%
  t() %>% 
  as.data.frame() %>% 
  mutate(tweet_id = as.integer(numextract(rownames(.))),
         tweet_id_char = rownames(.)) %>% 
  arrange(tweet_id)

# 计算每个推文的愤怒情绪平均感知值
data_or_trans_study3$mean_or <- data_or_trans_study3 %>% 
  select(-c(tweet_id, tweet_id_char)) %>% 
  rowMeans(., na.rm = TRUE)

# 计算每个推文的快乐情绪平均感知值
data_hap_trans_study3$mean_hap <- data_hap_trans_study3 %>% 
  select(-c(tweet_id, tweet_id_char)) %>% 
  rowMeans(., na.rm = TRUE)

# 将自我报告的评分数据加入到愤怒和快乐情绪的数据中
#以便于比较（join by tweet_id）
data_or_trans_study3 <- data_or_trans_study3 %>%
  left_join(self_report, by = "tweet_id")
data_hap_trans_study3 <- data_hap_trans_study3 %>%
  left_join(self_report, by = "tweet_id")

# 建立多层次模型
ncol(data_or_trans_study3)
# 数据准备
data_mlm_study3 <- data_or_trans_study3 %>% select(V1:V310, tweet_id, sr_outrage) %>% 
  pivot_longer(cols = -c(tweet_id, sr_outrage),
               values_to = "judgment",
               names_to = "pid",
               values_drop_na = TRUE)

# 添加被试类型标签
data_mlm_study3 <- data_mlm_study3 %>% mutate(name = "perceiver")

# 准备自我报告数据
self_report_trim_study3 <- self_report_study3 %>%
  select(tweet_id, sr_outrage) %>% 
  mutate(pid = as.character(row_number(tweet_id)))

# 创建作者数据集
data_mlm2_study3 <- data_mlm_study3 %>% 
  select(tweet_id) %>% 
  mutate(name = "author") %>%
  left_join(self_report_trim_study3, by = "tweet_id") %>% 
  mutate(judgment = sr_outrage)

# 确定列顺序并合并数据集
col_order <- c("tweet_id", "sr_outrage", "pid",
               "judgment", "name")

data_mlm2_study3 <- data_mlm2_study3[, col_order]

data_mlm3_study3 <- 
  rbind(data_mlm_study3, data_mlm2_study3) %>% 
  arrange(tweet_id) %>% 
  mutate(name_dum = ifelse(name == "author", 0, 1))


options(scipen = 999)

# 模型1拟合
model_or_study3 <- lmer(
  judgment ~ name + (1 | tweet_id) + (1 | pid),
  data = data_mlm3_study3
)
summary(model_or_study3)

round(confint(model_or_study3, level = 0.95),2)

# 观察者和作者愤怒评分的小提琴图
p_or_study3 <- ggplot(data_mlm3_study3, aes(
  x = name, y = judgment, fill = name)) +
  geom_violin(trim = FALSE, bw = 0.5) +
  geom_point(stat = "summary", fun = "mean", 
             color = "black", size = 3) +
  geom_errorbar(stat = "summary", 
                fun.data = mean_se, width = 0.2) +
  scale_fill_manual(
    values = c("author" = "lightgreen", 
               "perceiver" = "lightcoral")) +
  scale_y_continuous(breaks = 1:7, limits = c(1, 7)) +
  labs(x = "", y = " 愤怒评分", 
       title = " 观察者和作者愤怒评分的小提琴图") +
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 15),
    axis.text.x = element_text(size = 12),
    plot.title = element_text(size = 16, 
                              face = "bold", hjust = 0.5)
  )
print(p_or_study3)


# 建立多层次模型：和上面步骤一样，只是分析的情绪是happiness

data_mlmh_study3 <- data_hap_trans_study3 %>%
  select(V1:V310, tweet_id, sr_happy) %>% 
  pivot_longer(cols = -c(tweet_id, sr_happy),
               values_to = "judgment",
               names_to = "pid",
               values_drop_na = TRUE)

data_mlmh_study3 <- data_mlmh_study3 %>% 
  mutate(name = "perceiver")

self_report_trimh_study3 <- self_report_study3 %>%
  select(tweet_id, sr_happy) %>% 
  mutate(pid = as.character(row_number(tweet_id)))

data_mlm2h_study3 <- data_mlmh_study3 %>% 
  select(tweet_id) %>% 
  mutate(name = "author") %>%
  left_join(self_report_trimh_study3, by = "tweet_id") %>% 
  mutate(judgment = sr_happy)


col_orderh <- c("tweet_id", "sr_happy", "pid",
                "judgment", "name")

data_mlm2h_study3 <- data_mlm2h_study3[, col_orderh]


data_mlm3h_study3 <- rbind(data_mlmh_study3,
                           data_mlm2h_study3) %>% 
  arrange(tweet_id) %>% 
  mutate(name_dum = ifelse(name == "author", 0, 1))

options(scipen = 999)

# 模型2拟合
model_hap_study3<- lmer(
  judgment ~ name + (1 | tweet_id) + (1 |pid), 
  data = data_mlm3h_study3)
summary(model_hap_study3)

round(confint(model_hap_study3, level = 0.95),2)

# 观察者和作者快乐评分的小提琴图
p_hap_study3 <- 
  ggplot(data_mlm3h_study3, aes(
    x = name, y = judgment, fill = name)) +
  geom_violin(trim = FALSE, bw = 0.5) +
  geom_point(stat = "summary", 
             fun = "mean", color = "black", size = 3) +
  geom_errorbar(stat = "summary", 
                fun.data = mean_se, width = 0.2) +
  scale_fill_manual(values = 
                      c("author" = "lightgreen", 
                        "perceiver" = "lightcoral")) +
  scale_y_continuous(breaks = 1:7, limits = c(1, 7)) +
  labs(x = "", y = " 快乐评分", 
       title = " 观察者和作者快乐评分的小提琴图") +
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 15),
    axis.text.x = element_text(size = 12),
    plot.title = element_text(size = 16, 
                              face = "bold", hjust = 0.5)
  )
print(p_hap_study3)
```

## 政治媒体使用对过度感知的相关和回归
```{r,message=FALSE,warning=FALSE}
# 定义暗红色
dark_red <- "#8B0000" 
# 读取数据
op3 <- read_csv(
  "../osfstorage-archive/Data/study3_overperception.csv")

# 计算Pearson相关系数并保存结果
correlation_result_study3 <-
  cor.test(op3$sm_use_politics_slider, 
           op3$overperception, method = "pearson")

# 查看相关系数和P值
r_value_study3 <- correlation_result_study3$estimate
p_value_study3 <- correlation_result_study3$p.value

# 打印相关系数和P值
print(correlation_result_study3)

# 执行回归分析
model_study3 <- lm(overperception ~
                     scale(sm_use_politics_slider) +
                     scale(ideo_extr) + scale(p_identity),
                   data = op3)
summary(model_study3)

# 绘制散点图与回归线，使用暗红色
ggplot(op3, aes(x = sm_use_politics_slider, 
                y = overperception)) +
  geom_point(color = dark_red) +  # 散点图，颜色设置为暗红色
  geom_smooth(method = "lm", 
              formula = y ~ x, se = TRUE, 
              color = dark_red) +  
  # 线性回归线和置信区间，颜色设置为暗红色
  theme_minimal() +  # 使用简洁主题
  theme(plot.title = element_text(hjust = 0.5), 
        panel.grid = element_blank(),  # 去除网格线
        axis.line = element_line(color = "black")) +
  # 保留横轴和纵轴为黑色
  labs(title = paste("过度感知与社交媒体使用的相关性\n",
                     "r =", round(r_value_study3, 2),
                     ", P =", round(p_value_study3, 4)),
       x = "日常政治社交媒体使用",
       y = "对愤怒情绪的过度感知")
round(confint(model_study3, level = 0.95),2)
```

# 研究4
## 研究4用到的包、函数
```{r, message=FALSE}
packages <- c("lsr","rstatix","car")
 lapply(packages, function(pkg) {     
  if (!requireNamespace(pkg, quietly = TRUE)) { 
    install.packages(pkg, dependencies = TRUE)  
  }
})
 
library(lsr)
library(rstatix)
library(car)
 
data_study4 <- 
  read_csv("../osfstorage-archive/Data/study4_data_raw.csv")
stim_study4 <- 
  read_csv("../osfstorage-archive/Data/stim_descriptives_data.csv")

#计算汇总统计量的标准误差（Standard Error, SE）
summarySE <- function(
    data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)#对R语言中内置的ength函数的一个扩展
#增加了对 NA 的处理选项
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else length(x)
  } 
#指定的组（由groupvars定义）计算
#每个变量（由measurevar定义）的N、mean和sd
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
 # 重命名一个列，以及计算均值的标准误差
  datac <- rename(datac, c("mean" = measurevar))
  datac$se <- datac$sd / sqrt(datac$N) 
  #计算均值的置信区间
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  return(datac)
}
```

## 数据清洗
```{r 研究4数据清洗}
# 计算原始数据集data的行数，即记录数
data_study4 %>% nrow()

# 经过过滤后剩余的数据集
data_trim_study4 <- data_study4 %>% 
  filter(political_party == "Republican" | political_party == "Democrat")

# 被移除的记录数；除去没有政治党派倾向的参与者(N = 27)
nrow(data_study4) - nrow(data_trim_study4) 

# 进一步过滤data_trim，未通过理解性检查的参与者(N = 52)
data_trim_study4 <- data_trim_study4 %>% filter(barr_check + barrett_check == 2)

# final N = 523 剩余的样本大小
nrow(data_trim_study4)
```

## 描述性统计
```{r 研究4描述性统计}
# 绘制数据集data_trim中age字段（年龄）的直方图，用于可视化年龄的分布情况
hist(data_trim_study4$age)
mean(data_trim_study4$age, 
     na.rm = TRUE)#age字段的平均值，忽略NA值
sd(data_trim_study4$age, na.rm = TRUE)#计算age字段的标准差

# ideology；political_ideology字段（政治意识形态）的直方图
hist(data_trim_study4$political_ideology)

# party ；使用之前定义的frequencies.table函数为political_party字段生成频率表
frequencies.table(data_trim_study4$political_party)

# familiar with Barr；（对Barr的熟悉程度）生成频率表和百分比。
frequencies.table(data_trim_study4$barr_familiar)

# familiar with Barrett；对barrett_familiar字段（对Barrett的熟悉程度）
frequencies.table(data_trim_study4$barrett_familiar)

# gender；gender字段（性别）生成频率表和百分比
frequencies.table(data_trim_study4$gender)
```

## 设置数据集和变量，以便进行进一步的分析或可视化
```{r 设置数据集和变量}
#将原始数据集data写入名为"study4_data_raw.csv"的CSV文件
data_study4 %>% write_csv("../osfstorage-archive/Data/study4_data_raw.csv")

# make factor for plotting
#创建一个新变量condition_fac，将现有的condition变量转换为因子（factor）类型的变量
#并指定其水平（levels）为"High Overperception"和"Low Overperception"来创建的
data_trim_study4 <- data_trim_study4 %>%  
  mutate(condition_fac = 
           factor(condition, 
                  levels = c("High Overperception", 
                             "Low Overperception")))

```

## t检验
### 检验两个组别（高过度感知、低过度感知）在因变量（network_outrage）上是否存在显著差异，并且检查数据的正态性和方差齐性
```{r}
# 绘制直方图
hist(data_trim_study4$network_outrage[data_trim_study4$condition == "High Overperception"])
hist(data_trim_study4$network_outrage[data_trim_study4$condition == "Low Overperception"])

# 方差齐性检验
leveneTest(network_outrage ~ condition, data = data_trim_study4)

# t检验
t.test(network_outrage ~ condition, data = data_trim_study4, var.equal = FALSE)

# compute cohen's d 效应量计算
cohensD(network_outrage ~ condition, data = data_trim_study4)
```

### 两个单样本t检验，以比较两组（高过度感知和低过度感知）的network_outrage变量的均值与某个已知的均值（mu）是否存在显著差异
```{r}
# 数据准备
#筛选stim数据集中over_under字段等于"Overperceived"的记录，并存储为over_stim
over_stim <- stim_study4 %>% 
  filter(over_under == "Overperceived")
#筛选字段等于"Underperceived"的记录，并存储为under_stim
under_stim <- stim_study4 %>% filter(over_under == "Underperceived")

#从data_trim数据集中筛选出condition字段等于"High Overperception"的记录，并存储为over
over <- data_trim_study4 %>% filter(condition == "High Overperception")
#筛选出condition字段等于"Low Overperception"的记录，并存储为under
under <- data_trim_study4 %>% filter(condition == "Low Overperception")

#单样本t检验和Cohen's d计算
#对高过度感知组的network_outrage变量进行单样本t检验
#比较其均值与over_stim中or_mean变量的均值是否存在显著差异
t.test(over$network_outrage, mu = mean(over_stim$or_mean), alternative = "two.sided")
cohensD(over$network_outrage, mu = mean(over_stim$or_mean)) #Cohen's d效应量

#低过度感知组
t.test(under$network_outrage, mu = mean(under_stim$or_mean), alternative = "two.sided")
cohensD(under$network_outrage, mu = mean(under_stim$or_mean))

```

### plot group outrage judgments ----可视化
```{r, warning=FALSE}
data_trim_study4 %>% 
  ggplot(aes(x = condition_fac, y = network_outrage, fill = condition_fac)) + #x轴代表条件，y轴代表感知到的网络愤怒程度
  geom_jitter(aes(color = condition_fac),
              alpha = .3,
              width = .2) +
  stat_summary(fun.data = "mean_cl_boot", geom = "crossbar", 
               position = position_dodge(width=1),
               size=.3, width=.4, alpha=.6) +
  xlab("Condition") +
  ylab("Perceived Network Outrage") +
  theme_bw() +
  theme(panel.border = element_blank(), axis.line = element_line()) +
  scale_fill_manual(values=c("#a82424", "#787776")) +
  scale_color_manual(values=c("#a82424", "#787776")) +
  scale_y_continuous(breaks = seq(1, 7, by = 1)) +
  geom_hline(yintercept = 5.30, linetype = "dashed", color = "#a82424", size = 1, alpha = .5) +
  geom_hline(yintercept = 3.41, linetype = "dashed", color = "#787776", size = 1, alpha = .5) +#添加两条虚线，表示之前单样本t检验中使用的两个均值（5.30和3.41）
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme(text=element_text(size = 15, face = 'bold')) +
  #theme(legend.position = c(.82, .92)) +
  theme(legend.position = "none") +
  theme(legend.title = element_blank())
```

# 研究5
## 读取文件和数据清洗
```{r, message=FALSE}
#读取文件
data_study5 <- read_csv("../osfstorage-archive/Data/study5_data_raw.csv")

# 计算原始数据中的观测数
data_study5 %>% group_by(id) %>% dplyr::summarize(n = n()) %>% nrow(.)

# 过滤数据移除非共和党或者民主党的被试
data_trim_study5 <- data_study5 %>% 
  filter(political_party == "Republican" | political_party == "Democrat")

# 再次计算过滤后数据中的观测数
data_trim_study5 %>% group_by(id) %>% dplyr::summarize(n = n()) %>% nrow(.)

# 移除了87个不符合上面check观测数的被试，现在被试量剩下1013
data_trim_study5 <- data_trim_study5 %>% filter(barr_check + barrett_check == 2)

# 计算最终的观测数
data_trim_study5 %>% group_by(id) %>% dplyr::summarize(n = n()) %>% nrow(.)
```

## 描述统计
```{r}
# 计算描述性统计量
descriptives <- data_trim_study5 %>% group_by(id) %>% 
  summarize_all(list(first))

# 性别频率表
frequencies.table(descriptives$gender)


# 年龄直方图
hist(descriptives$age)

# 政治意识形态直方图
frequency <- descriptives %>%
  count(political_ideology)
frequency_df <- as.data.frame(frequency)
print(frequency_df)

ggplot(frequency, aes(x = political_ideology, y = n)) +
  geom_bar(stat = "identity", width = 0.9, fill = "steelblue") +
  scale_x_discrete(limits = 1:7) +  # 确保x轴包括所有水平
  theme_minimal() +
  labs(x = "Political Ideology", y = "Frequency")  # 设置轴标签
  theme_minimal()  # 使用简洁的主题

# party的频数
frequencies.table(descriptives$political_party)

# Barr的熟悉度的频数
frequencies.table(descriptives$barr_familiar)

# Barrett的熟悉度的频数
frequencies.table(descriptives$barrett_familiar)
```

## 创建新变量
```{r}
# 重新编码政治意识形态网络
descriptives <- descriptives %>% 
  mutate(ideo_network_recode = 
           dplyr::recode(ideo_network, 
                         `1` = -3L,
                         `2`= -2L, 
                         `3` = -1L, 
                         `4` = 0L,
                         `5` = 1L,
                         `6` = 2L,
                         `7` = 3L))

# 创建自我党派和其他党派的情感温度评分
# 如果是"Democrat"，那么ownparty_temp列使用dem_network_temp列的值
#如果不是民主党人，那么将使用rep_network_temp列的值。
descriptives <- descriptives %>% 
  mutate(ownparty_temp = 
           ifelse(political_party == "Democrat", 
                  dem_network_temp, rep_network_temp),
         otherparty_temp =
           ifelse(political_party == "Democrat", 
                  rep_network_temp, dem_network_temp),
         ideo_extr_network = abs(ideo_network_recode))


# 为绘图设置因子
descriptives <- descriptives %>%  
  mutate(condition_fac = 
           factor(condition, levels = 
                    c("High Overperception", "Low Overperception")))


# 过滤数据集，只保留民主党和共和党参与者的数据，然后按条件分组，并计算三个变量的均值
descriptives_plot <- descriptives %>% 
  filter(political_party == "Democrat" | political_party == "Republican") %>% 
  group_by(condition) %>% 
  dplyr::summarize(ownparty_temp = mean(ownparty_temp),
                   otherparty_temp = mean(otherparty_temp),
                   ideo_extr_network = mean(ideo_extr_network))

```

## 画图前对数据框的一些整理
```{r, message=FALSE}
# 推文的分组替换成更加简洁的标签
data_trim_study5 <- data_trim_study5 %>% 
  mutate(norm_stim_label_group = 
           case_when(grepl("dem_high", norm_stim) ~ "dem_high",
                     grepl("dem_low", norm_stim ) ~"dem_low",
                     grepl("rep_high", norm_stim ) ~"rep_high",
                     grepl("rep_low", norm_stim ) ~"rep_low")) 

# remove author tweet who opted out after experiment was run
# 移除在实验运行后选择退出的作者的推文
data_trim_study5 <- data_trim_study5 %>% filter(norm_stim != "rep_high_64_1")


stim_approp <- data_trim_study5 %>% 
  filter(political_party == "Democrat" | political_party == "Republican") %>%
  group_by(id, condition, norm_stim_label_group) %>% 
  dplyr::summarize(mean = mean(appropriate_rating))

# spread()函数将stim_approp数据框从长格式转换为宽格式
stim_approp_w <- spread(stim_approp, norm_stim_label_group, mean) %>% 
  mutate(dem_diff = dem_high - dem_low,
         rep_diff = rep_high - rep_low) %>% 
  mutate(diff = ifelse(is.na(dem_diff), rep_diff, dem_diff)) %>% 
  ungroup() %>% 
  select(id, diff)


stim_approp <- stim_approp %>% 
  left_join(stim_approp_w, by = "id")

stim_approp_plot <- stim_approp %>% 
  group_by(id) %>% dplyr::summarize(condition = first(condition),
                                       diff = first(diff))
stim_approp_plot <- stim_approp_plot %>%
  mutate(condition_fac = 
           factor(condition, levels = 
                    c("High Overperception", "Low Overperception")))
```

## 画图
### x：高低感知 y：评分差 x轴代表条件（condition_fac）也就是接受的信息是高愤怒感知和低愤怒感知组，y轴代表适当性评分差异分数（diff）
```{r, warning=FALSE}
# plot
stim_approp_plot %>% 
  ggplot(aes(x = condition_fac, y = diff, fill = condition_fac)) +
  geom_jitter(aes(color = condition_fac),
              alpha = .3,
              width = .27) +
  stat_summary(fun.data = "mean_cl_boot", geom = "crossbar", 
               position = position_dodge(width=1),
               size=.3, width=.5, alpha=.6) +
  xlab("Condition") +
  ylab("Appropriate Rating Difference Score") +
  ggtitle("新闻源条件下的社会适应性") + 
  theme_bw() +
  theme(panel.border = element_blank(), axis.line = element_line()) +
  scale_fill_manual(values=c("#a82424", "#787776")) +
  scale_color_manual(values=c("#a82424", "#787776")) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  theme(text = element_text(size = 19, face = 'bold')) +
  theme(legend.position = "none") +
  theme(legend.title = element_blank()) +
  theme(plot.title = 
          element_text(size = 11, hjust = 0.5, 
                       face = "bold", color = "black")) # 设置标题格式

```

## 结果
```{r, warning=FALSE}
# test network norms 检查因变量的分布----
hist(stim_approp_plot$diff[stim_approp$condition == "High Overperception"])
hist(stim_approp_plot$diff[stim_approp$condition == "Low Overperception"])

# test for homogeneity of variance (violated) 方差齐性检验
leveneTest(diff ~ condition, data = stim_approp_plot)

# t-test, not assume equal variances 独立样本t检验
t.test(diff ~ condition, data = stim_approp_plot, var.equal = FALSE)

# compute cohen's d 计算效应量值
cohensD(diff ~ condition, data = stim_approp_plot)
```

## 画图
### x轴：内外群体 y轴：感知到的情感温度
```{r, warning=FALSE}
## plot network therm ----

ownparty <- descriptives %>% select(id, ownparty_temp) %>% 
  rename(temp = ownparty_temp) %>% 
  mutate(network = "Ingroup") %>% 
  cbind(descriptives$condition) %>% 
  rename(condition = `descriptives$condition`)

otherparty <- descriptives %>% select(id, otherparty_temp) %>% 
  rename(temp = otherparty_temp) %>% 
  mutate(network = "Outgroup") %>% 
  cbind(descriptives$condition) %>% 
  rename(condition = `descriptives$condition`)

plot_therm <- rbind(ownparty, otherparty)

plot_therm <- plot_therm %>%  
  mutate(condition_fac = 
           factor(condition, 
                  levels = c("High Overperception", "Low Overperception")))
  
plot_therm %>% 
  ggplot(aes(x = network, y = temp, fill = condition_fac)) +
  geom_point(position = position_jitterdodge(dodge.width = 1, jitter.width = .5),
             aes(color = condition_fac, fill = condition_fac),
              alpha = .3) +
  stat_summary(fun.data = "mean_cl_boot", geom = "crossbar", 
               position = position_dodge(width=1),
               size=.3, width=.5, alpha=.6) +
  xlab("Political Group") +
  ylab("Percieved Network Feeling") +
  ggtitle("新闻源条件下的群体极化")+
  theme_bw() +
  theme(panel.border = element_blank(), axis.line = element_line()) +
  scale_fill_manual(values=c("#a82424", "#787776")) +
  scale_color_manual(values=c("#a82424", "#787776")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme(text=element_text(size = 19, face = 'bold')) +
  theme(legend.position = c(.75, .92)) +
  theme(legend.title = element_blank())+
  theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold", color = "black"))
class(plot_therm$condition_fac)
```

## 两因素混合方差分析
```{r, warning=FALSE}
# two-way mixed ANOVA, network therm ----
anova <- anova_test(
  data = plot_therm, dv = temp, wid = id,
  between = condition, within = network, effect.size = "pes")

get_anova_table(anova)
```

## 画图
### x:内外群体 y：意识形态的极端性
```{r, warning=FALSE}
## plot ideo_extr ----

descriptives %>% 
  ggplot(aes(x = condition_fac, y = ideo_extr_network, fill = condition_fac)) +
  geom_jitter(aes(color = condition_fac),
              alpha = .3,
              width = .27) +
  stat_summary(fun.data = "mean_cl_boot", geom = "crossbar", 
               position = position_dodge(width=1),
               size=.3, width=.5, alpha=.6) +
  xlab("Condition") +
  ylab("Perceived Ideological Extremity") +
  ggtitle("新闻源条件下感知到的意识形态极端性") + # 添加图表标题
  theme_bw() +
  theme(panel.border = element_blank(), axis.line = element_line()) +
  scale_fill_manual(values=c("#a82424", "#787776")) +
  scale_color_manual(values=c("#a82424", "#787776")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme(text=element_text(size = 19, face = 'bold')) +
  theme(legend.position = "none") +
  theme(legend.title = element_blank()) +
  theme(plot.title = 
          element_text(size = 11, hjust = 0.5, 
                       face = "bold", color = "black")) # 设置标题格式

```

## t检验
```{r, warning=FALSE}
# t-test ideo_extr ----

# examine distribution of DV
# overperception looks normal, note outlier in accurate perception
hist(descriptives$ideo_extr_network[descriptives$condition == "High Overperception"])
hist(descriptives$ideo_extr_network[descriptives$condition == "Low Overperception"])

# test for homogeneity of variance (violated)
leveneTest(ideo_extr_network ~ condition, data = descriptives)

# t-test, not assume equal variances
t.test(ideo_extr_network ~ condition, data = descriptives, var.equal = FALSE)

# compute cohen's d
cohensD(ideo_extr_network ~ condition, data = descriptives)


```
